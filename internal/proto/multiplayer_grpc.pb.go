// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.3
// source: multiplayer.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MultiplayerService_GetModeUsage_FullMethodName             = "/multiplayer.MultiplayerService/GetModeUsage"
	MultiplayerService_GetTotalActiveUsers_FullMethodName      = "/multiplayer.MultiplayerService/GetTotalActiveUsers"
	MultiplayerService_GetModeDetails_FullMethodName           = "/multiplayer.MultiplayerService/GetModeDetails"
	MultiplayerService_GetActiveUsersByAreaCode_FullMethodName = "/multiplayer.MultiplayerService/GetActiveUsersByAreaCode"
	MultiplayerService_GetGameModeStats_FullMethodName         = "/multiplayer.MultiplayerService/GetGameModeStats"
	MultiplayerService_JoinMode_FullMethodName                 = "/multiplayer.MultiplayerService/JoinMode"
	MultiplayerService_LeaveMode_FullMethodName                = "/multiplayer.MultiplayerService/LeaveMode"
	MultiplayerService_GetPlayers_FullMethodName               = "/multiplayer.MultiplayerService/GetPlayers"
	MultiplayerService_UpdateGameState_FullMethodName          = "/multiplayer.MultiplayerService/UpdateGameState"
)

// MultiplayerServiceClient is the client API for MultiplayerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Service definition for Multiplayer API
type MultiplayerServiceClient interface {
	GetModeUsage(ctx context.Context, in *ModeUsageRequest, opts ...grpc.CallOption) (*ModeUsageResponse, error)
	GetTotalActiveUsers(ctx context.Context, in *TotalActiveUsersRequest, opts ...grpc.CallOption) (*TotalActiveUsersResponse, error)
	// New methods
	GetModeDetails(ctx context.Context, in *ModeDetailsRequest, opts ...grpc.CallOption) (*ModeDetailsResponse, error)
	GetActiveUsersByAreaCode(ctx context.Context, in *ActiveUsersByAreaCodeRequest, opts ...grpc.CallOption) (*ActiveUsersByAreaCodeResponse, error)
	GetGameModeStats(ctx context.Context, in *GameModeStatsRequest, opts ...grpc.CallOption) (*GameModeStatsResponse, error)
	JoinMode(ctx context.Context, in *JoinModeRequest, opts ...grpc.CallOption) (*JoinModeResponse, error)
	LeaveMode(ctx context.Context, in *LeaveModeRequest, opts ...grpc.CallOption) (*LeaveModeResponse, error)
	GetPlayers(ctx context.Context, in *GetPlayersRequest, opts ...grpc.CallOption) (*GetPlayersResponse, error)
	UpdateGameState(ctx context.Context, in *UpdateGameStateRequest, opts ...grpc.CallOption) (*UpdateGameStateResponse, error)
}

type multiplayerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMultiplayerServiceClient(cc grpc.ClientConnInterface) MultiplayerServiceClient {
	return &multiplayerServiceClient{cc}
}

func (c *multiplayerServiceClient) GetModeUsage(ctx context.Context, in *ModeUsageRequest, opts ...grpc.CallOption) (*ModeUsageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModeUsageResponse)
	err := c.cc.Invoke(ctx, MultiplayerService_GetModeUsage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *multiplayerServiceClient) GetTotalActiveUsers(ctx context.Context, in *TotalActiveUsersRequest, opts ...grpc.CallOption) (*TotalActiveUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TotalActiveUsersResponse)
	err := c.cc.Invoke(ctx, MultiplayerService_GetTotalActiveUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *multiplayerServiceClient) GetModeDetails(ctx context.Context, in *ModeDetailsRequest, opts ...grpc.CallOption) (*ModeDetailsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ModeDetailsResponse)
	err := c.cc.Invoke(ctx, MultiplayerService_GetModeDetails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *multiplayerServiceClient) GetActiveUsersByAreaCode(ctx context.Context, in *ActiveUsersByAreaCodeRequest, opts ...grpc.CallOption) (*ActiveUsersByAreaCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ActiveUsersByAreaCodeResponse)
	err := c.cc.Invoke(ctx, MultiplayerService_GetActiveUsersByAreaCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *multiplayerServiceClient) GetGameModeStats(ctx context.Context, in *GameModeStatsRequest, opts ...grpc.CallOption) (*GameModeStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GameModeStatsResponse)
	err := c.cc.Invoke(ctx, MultiplayerService_GetGameModeStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *multiplayerServiceClient) JoinMode(ctx context.Context, in *JoinModeRequest, opts ...grpc.CallOption) (*JoinModeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinModeResponse)
	err := c.cc.Invoke(ctx, MultiplayerService_JoinMode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *multiplayerServiceClient) LeaveMode(ctx context.Context, in *LeaveModeRequest, opts ...grpc.CallOption) (*LeaveModeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LeaveModeResponse)
	err := c.cc.Invoke(ctx, MultiplayerService_LeaveMode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *multiplayerServiceClient) GetPlayers(ctx context.Context, in *GetPlayersRequest, opts ...grpc.CallOption) (*GetPlayersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPlayersResponse)
	err := c.cc.Invoke(ctx, MultiplayerService_GetPlayers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *multiplayerServiceClient) UpdateGameState(ctx context.Context, in *UpdateGameStateRequest, opts ...grpc.CallOption) (*UpdateGameStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateGameStateResponse)
	err := c.cc.Invoke(ctx, MultiplayerService_UpdateGameState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MultiplayerServiceServer is the server API for MultiplayerService service.
// All implementations must embed UnimplementedMultiplayerServiceServer
// for forward compatibility.
//
// Service definition for Multiplayer API
type MultiplayerServiceServer interface {
	GetModeUsage(context.Context, *ModeUsageRequest) (*ModeUsageResponse, error)
	GetTotalActiveUsers(context.Context, *TotalActiveUsersRequest) (*TotalActiveUsersResponse, error)
	// New methods
	GetModeDetails(context.Context, *ModeDetailsRequest) (*ModeDetailsResponse, error)
	GetActiveUsersByAreaCode(context.Context, *ActiveUsersByAreaCodeRequest) (*ActiveUsersByAreaCodeResponse, error)
	GetGameModeStats(context.Context, *GameModeStatsRequest) (*GameModeStatsResponse, error)
	JoinMode(context.Context, *JoinModeRequest) (*JoinModeResponse, error)
	LeaveMode(context.Context, *LeaveModeRequest) (*LeaveModeResponse, error)
	GetPlayers(context.Context, *GetPlayersRequest) (*GetPlayersResponse, error)
	UpdateGameState(context.Context, *UpdateGameStateRequest) (*UpdateGameStateResponse, error)
	mustEmbedUnimplementedMultiplayerServiceServer()
}

// UnimplementedMultiplayerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMultiplayerServiceServer struct{}

func (UnimplementedMultiplayerServiceServer) GetModeUsage(context.Context, *ModeUsageRequest) (*ModeUsageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModeUsage not implemented")
}
func (UnimplementedMultiplayerServiceServer) GetTotalActiveUsers(context.Context, *TotalActiveUsersRequest) (*TotalActiveUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTotalActiveUsers not implemented")
}
func (UnimplementedMultiplayerServiceServer) GetModeDetails(context.Context, *ModeDetailsRequest) (*ModeDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModeDetails not implemented")
}
func (UnimplementedMultiplayerServiceServer) GetActiveUsersByAreaCode(context.Context, *ActiveUsersByAreaCodeRequest) (*ActiveUsersByAreaCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveUsersByAreaCode not implemented")
}
func (UnimplementedMultiplayerServiceServer) GetGameModeStats(context.Context, *GameModeStatsRequest) (*GameModeStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGameModeStats not implemented")
}
func (UnimplementedMultiplayerServiceServer) JoinMode(context.Context, *JoinModeRequest) (*JoinModeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinMode not implemented")
}
func (UnimplementedMultiplayerServiceServer) LeaveMode(context.Context, *LeaveModeRequest) (*LeaveModeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveMode not implemented")
}
func (UnimplementedMultiplayerServiceServer) GetPlayers(context.Context, *GetPlayersRequest) (*GetPlayersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPlayers not implemented")
}
func (UnimplementedMultiplayerServiceServer) UpdateGameState(context.Context, *UpdateGameStateRequest) (*UpdateGameStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGameState not implemented")
}
func (UnimplementedMultiplayerServiceServer) mustEmbedUnimplementedMultiplayerServiceServer() {}
func (UnimplementedMultiplayerServiceServer) testEmbeddedByValue()                            {}

// UnsafeMultiplayerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MultiplayerServiceServer will
// result in compilation errors.
type UnsafeMultiplayerServiceServer interface {
	mustEmbedUnimplementedMultiplayerServiceServer()
}

func RegisterMultiplayerServiceServer(s grpc.ServiceRegistrar, srv MultiplayerServiceServer) {
	// If the following call pancis, it indicates UnimplementedMultiplayerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MultiplayerService_ServiceDesc, srv)
}

func _MultiplayerService_GetModeUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModeUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MultiplayerServiceServer).GetModeUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MultiplayerService_GetModeUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MultiplayerServiceServer).GetModeUsage(ctx, req.(*ModeUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MultiplayerService_GetTotalActiveUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TotalActiveUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MultiplayerServiceServer).GetTotalActiveUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MultiplayerService_GetTotalActiveUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MultiplayerServiceServer).GetTotalActiveUsers(ctx, req.(*TotalActiveUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MultiplayerService_GetModeDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModeDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MultiplayerServiceServer).GetModeDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MultiplayerService_GetModeDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MultiplayerServiceServer).GetModeDetails(ctx, req.(*ModeDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MultiplayerService_GetActiveUsersByAreaCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActiveUsersByAreaCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MultiplayerServiceServer).GetActiveUsersByAreaCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MultiplayerService_GetActiveUsersByAreaCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MultiplayerServiceServer).GetActiveUsersByAreaCode(ctx, req.(*ActiveUsersByAreaCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MultiplayerService_GetGameModeStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameModeStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MultiplayerServiceServer).GetGameModeStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MultiplayerService_GetGameModeStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MultiplayerServiceServer).GetGameModeStats(ctx, req.(*GameModeStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MultiplayerService_JoinMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MultiplayerServiceServer).JoinMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MultiplayerService_JoinMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MultiplayerServiceServer).JoinMode(ctx, req.(*JoinModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MultiplayerService_LeaveMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MultiplayerServiceServer).LeaveMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MultiplayerService_LeaveMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MultiplayerServiceServer).LeaveMode(ctx, req.(*LeaveModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MultiplayerService_GetPlayers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPlayersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MultiplayerServiceServer).GetPlayers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MultiplayerService_GetPlayers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MultiplayerServiceServer).GetPlayers(ctx, req.(*GetPlayersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MultiplayerService_UpdateGameState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGameStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MultiplayerServiceServer).UpdateGameState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MultiplayerService_UpdateGameState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MultiplayerServiceServer).UpdateGameState(ctx, req.(*UpdateGameStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MultiplayerService_ServiceDesc is the grpc.ServiceDesc for MultiplayerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MultiplayerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "multiplayer.MultiplayerService",
	HandlerType: (*MultiplayerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetModeUsage",
			Handler:    _MultiplayerService_GetModeUsage_Handler,
		},
		{
			MethodName: "GetTotalActiveUsers",
			Handler:    _MultiplayerService_GetTotalActiveUsers_Handler,
		},
		{
			MethodName: "GetModeDetails",
			Handler:    _MultiplayerService_GetModeDetails_Handler,
		},
		{
			MethodName: "GetActiveUsersByAreaCode",
			Handler:    _MultiplayerService_GetActiveUsersByAreaCode_Handler,
		},
		{
			MethodName: "GetGameModeStats",
			Handler:    _MultiplayerService_GetGameModeStats_Handler,
		},
		{
			MethodName: "JoinMode",
			Handler:    _MultiplayerService_JoinMode_Handler,
		},
		{
			MethodName: "LeaveMode",
			Handler:    _MultiplayerService_LeaveMode_Handler,
		},
		{
			MethodName: "GetPlayers",
			Handler:    _MultiplayerService_GetPlayers_Handler,
		},
		{
			MethodName: "UpdateGameState",
			Handler:    _MultiplayerService_UpdateGameState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "multiplayer.proto",
}
